<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Crispoparte V8 - Final</title>
  <style>
    :root {
      --accent: #25D366;
      --primary: #FF5722;
      --record: #ff0000;
      --bg-overlay: rgba(0, 0, 0, 0.65);
    }
    
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body { 
      margin: 0; background: #000; color: #fff; overflow: hidden; 
      width: 100vw; height: 100dvh; 
      font-family: sans-serif;
    }

    .frame { position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #000; }
    .stage { position: relative; width: 100%; height: 100%; overflow: hidden; background: #111; }

    video, #molduraPreview, #canvasPreview, #videoPreview { 
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; 
    }

    video { transform: scaleX(1); transition: transform 0.3s; }
    video.mirrored { transform: scaleX(-1); }

    #molduraPreview { pointer-events: none; z-index: 5; }
    #canvasPreview, #videoPreview { display: none; z-index: 6; background: #000; }

    /* UI Layers */
    .ui-layer {
      position: absolute; inset: 0; pointer-events: none; z-index: 20;
      display: flex; flex-direction: column; justify-content: space-between; padding: 20px;
    }

    .top-bar { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: auto; }

    .timer-badge {
        background: red; color: white; padding: 5px 12px; border-radius: 12px;
        font-weight: bold; font-size: 16px; display: none; animation: pulse 1s infinite;
    }
    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

    .controls-bottom {
      display: flex; flex-direction: column; align-items: center; gap: 15px; pointer-events: auto; padding-bottom: 20px;
    }

    .mode-switch {
        display: flex; background: rgba(0,0,0,0.5); border-radius: 20px; padding: 4px; backdrop-filter: blur(4px);
    }
    .mode-btn {
        padding: 8px 20px; border-radius: 16px; border: none; background: transparent; color: #ccc; font-weight: 600; cursor: pointer;
    }
    .mode-btn.active { background: #fff; color: #000; }

    .btn { 
      padding: 10px 16px; font-size: 14px; font-weight: 600;
      border: 2px solid rgba(255,255,255,0.3); border-radius: 20px; 
      background: var(--bg-overlay); color: #fff; cursor: pointer; backdrop-filter: blur(4px);
    }
    .btn.active { border-color: var(--accent); background: rgba(37, 211, 102, 0.2); color: var(--accent); }
    .frame-selector { display: flex; gap: 10px; }

    /* Bot√£o de Captura */
    #captureBtn { 
      width: 80px; height: 80px; border-radius: 50%; border: 4px solid #fff; 
      background: rgba(255,255,255,0.2); cursor: pointer; display: flex; 
      align-items: center; justify-content: center; transition: all 0.2s;
    }
    #captureBtn:active { transform: scale(0.95); }
    #captureBtn svg { width: 36px; height: 36px; fill: #fff; }

    /* Estado Gravando */
    #captureBtn.recording { border-color: var(--record); background: rgba(255, 0, 0, 0.5); }
    #captureBtn.recording svg { fill: var(--record); }
    #captureBtn .stop-icon { display: none; width: 30px; height: 30px; background: var(--record); border-radius: 4px; }
    #captureBtn.recording .stop-icon { display: block; }
    #captureBtn.recording .cam-icon { display: none; }

    #startScreen { 
      position: absolute; inset: 0; background: #000; z-index: 50; 
      display: flex; flex-direction: column; align-items: center; justify-content: center; 
      gap: 20px; text-align: center;
    }
    #startBtn { padding: 18px 32px; font-size: 20px; background: var(--primary); color: white; border: none; border-radius: 50px; cursor: pointer; }

    #postCaptureActions { display: none; flex-direction: column; gap: 12px; width: 100%; max-width: 300px; pointer-events: auto; }
    
    .action-btn { width: 100%; padding: 14px; border-radius: 12px; border: none; font-size: 16px; font-weight: bold; cursor: pointer; text-align: center; text-decoration: none; display: inline-block; }
    .btn-save { background: var(--accent); color: #fff; }
    .btn-new { background: #555; color: #fff; }
    .flash { position: absolute; inset: 0; background: #fff; opacity: 0; pointer-events: none; z-index: 10; transition: opacity 0.1s; }
  </style>
</head>
<body>

  <div class="frame">
    <div class="stage" id="stage">
      <video id="camera" autoplay playsinline muted></video>
      <canvas id="canvasPreview"></canvas> 
      <video id="videoPreview" playsinline controls></video>
      <img id="molduraPreview" alt="" src="" />
      <div class="flash" id="flash"></div>

      <div class="ui-layer" id="cameraUI" style="display: none;">
        <div class="top-bar">
          <button class="btn" id="switchBtn">üîÑ Trocar</button>
          <div id="recordingTimer" class="timer-badge">00:00</div>
        </div>

        <div class="controls-bottom">
          <div class="mode-switch">
             <button class="mode-btn active" id="modePhoto">FOTO</button>
             <button class="mode-btn" id="modeVideo">V√çDEO</button>
          </div>

          <div class="frame-selector">
            <button class="btn active" id="m1Btn">1</button>
            <button class="btn" id="m2Btn">2</button>
          </div>

          <button id="captureBtn">
            <svg class="cam-icon" viewBox="0 0 24 24"><path d="M12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/><path d="M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 14H4V7h16v12z"/></svg>
            <div class="stop-icon"></div>
          </button>
        </div>
      </div>

      <div class="ui-layer" id="resultUI" style="display: none; justify-content: flex-end; align-items: center;">
        <div id="postCaptureActions">
          <a id="downloadBtn" class="action-btn btn-save">üì• Baixar / Salvar</a>
          <button id="newPhotoBtn" class="action-btn btn-new">üîÑ Novo</button>
        </div>
      </div>
    </div>
  </div>

  <div id="startScreen">
    <h2 style="margin-bottom:0">C√¢mera Crispoparte</h2>
    <p style="color:#aaa; margin-top:5px">Permita c√¢mera e microfone</p>
    <button id="startBtn">INICIAR</button>
    <p id="errorMsg" style="color:red; font-size:12px; margin-top: 10px;"></p>
  </div>

  <canvas id="canvasFinal" style="display: none;"></canvas>

  <script>
    // --- Config ---
    const MOLDURAS = { 'm1': 'moldura1.png', 'm2': 'moldura2.png' };
    let currentMolduraUrl = MOLDURAS['m1'];
    let usingFrontCamera = true;
    let stream = null;
    let currentMode = 'photo'; 
    let isRecording = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordingStartTime = 0;
    let animationFrameId = null;
    
    let finalMimeType = null;
    let finalFileExtension = null;
    let currentBlobUrl = null; 
    
    // VARI√ÅVEL CR√çTICA: Armazena o OBJETO BLOB (dados puros) e o nome do arquivo
    let currentDownloadData = { blob: null, filename: null }; 

    // --- DOM Elements ---
    const video = document.getElementById('camera');
    const stage = document.getElementById('stage');
    const canvasPreview = document.getElementById('canvasPreview');
    const videoPreview = document.getElementById('videoPreview');
    const molduraPreview = document.getElementById('molduraPreview');
    const canvasFinal = document.getElementById('canvasFinal');
    const ctxFinal = canvasFinal.getContext('2d', { alpha: false });
    
    const startScreen = document.getElementById('startScreen');
    const cameraUI = document.getElementById('cameraUI');
    const resultUI = document.getElementById('resultUI');
    const captureBtn = document.getElementById('captureBtn');
    const recordingTimer = document.getElementById('recordingTimer');
    const errorMsg = document.getElementById('errorMsg');
    const downloadBtn = document.getElementById('downloadBtn');

    // --- Events ---
    setMoldura(document.getElementById('m1Btn'), 'm1');
    document.getElementById('startBtn').addEventListener('click', () => initCamera(true)); 
    document.getElementById('switchBtn').addEventListener('click', switchCamera);
    document.getElementById('newPhotoBtn').addEventListener('click', resetCamera);
    document.getElementById('m1Btn').addEventListener('click', (e) => setMoldura(e.target, 'm1'));
    document.getElementById('m2Btn').addEventListener('click', (e) => setMoldura(e.target, 'm2'));
    document.getElementById('modePhoto').addEventListener('click', () => setMode('photo'));
    document.getElementById('modeVideo').addEventListener('click', () => setMode('video'));
    
    captureBtn.addEventListener('click', () => {
        if (currentMode === 'photo') takePhoto();
        else {
            if (!isRecording) startRecording();
            else stopRecording();
        }
    });

    // NOVO: A√ß√£o de download for√ßada pelo BLOB
    downloadBtn.addEventListener('click', triggerDownload);
    
    // --- Download Program√°tico Corrigido (M√°xima Prioridade) ---
    function triggerDownload() {
        const { blob, filename } = currentDownloadData;
        
        if (!blob || !filename) {
            alert("Erro: Arquivo n√£o encontrado para download. Tente uma nova grava√ß√£o.");
            return;
        }

        // 1. Cria a URL do objeto APENAS NO MOMENTO DO DOWNLOAD (Evita cache)
        const url = URL.createObjectURL(blob);
        
        // 2. Cria um link tempor√°rio no DOM
        const tempLink = document.createElement('a');
        tempLink.style.display = 'none';
        
        // 3. Define o HREF e o download
        tempLink.href = url;
        tempLink.download = filename;
        
        // 4. Clica e remove (Garante que o download use o Blob atual)
        document.body.appendChild(tempLink);
        tempLink.click();
        document.body.removeChild(tempLink);
        
        // 5. Revoga a URL imediatamente ap√≥s o clique para limpar a mem√≥ria
        URL.revokeObjectURL(url); 
    }
    
    // --- Fun√ß√µes Principais de C√¢mera e Captura ---
    
    function setMode(mode) {
        currentMode = mode;
        document.getElementById('modePhoto').className = mode === 'photo' ? 'mode-btn active' : 'mode-btn';
        document.getElementById('modeVideo').className = mode === 'video' ? 'mode-btn active' : 'mode-btn';
        captureBtn.style.borderColor = mode === 'video' ? '#ff0000' : '#fff';
    }

    function setMoldura(btn, key) {
      document.querySelectorAll('.frame-selector .btn').forEach(b => b.classList.remove('active'));
      if(btn) btn.classList.add('active');
      currentMolduraUrl = MOLDURAS[key];
      molduraPreview.src = currentMolduraUrl;
    }

    async function initCamera(tryAudio = true) {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null; 
      }
      errorMsg.innerText = "Solicitando permiss√µes...";

      const currentFacingMode = usingFrontCamera ? 'user' : 'environment';
      
      const constraintsList = [
        { video: { facingMode: currentFacingMode, width: { ideal: 1280 }, height: { ideal: 720 } } },
        { video: { facingMode: currentFacingMode, width: { ideal: 640 }, height: { ideal: 480 } } },
        { video: { facingMode: currentFacingMode } }
      ];

      for (const videoConstraints of constraintsList) {
        let constraints = { ...videoConstraints }; 
        if (tryAudio) { constraints.audio = true; }

        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          handleStreamSuccess(stream);
          return; 
        } catch (err) {
          console.warn(`Tentativa falhou com restri√ß√µes:`, constraints, `Erro: ${err.name}`);
        }
      }

      if (tryAudio) {
           errorMsg.innerText = "Erro no √°udio. Tentando iniciar sem microfone...";
           await initCamera(false); 
      } else {
           const errMsg = `FALHA CR√çTICA! A c√¢mera e o √°udio n√£o puderam ser inicializados.`;
           errorMsg.innerText = errMsg;
           alert(errMsg); 
      }
    }

    function handleStreamSuccess(newStream) {
        stream = newStream;
        video.srcObject = stream;
        
        if (usingFrontCamera) video.classList.add('mirrored');
        else video.classList.remove('mirrored');

        video.onloadedmetadata = () => {
          video.play();
          startScreen.style.display = 'none';
          cameraUI.style.display = 'flex';
          errorMsg.innerText = "";
        };
    }

    async function switchCamera() {
      if (isRecording) stopRecording(); 
      usingFrontCamera = !usingFrontCamera;
      
      await new Promise(resolve => setTimeout(resolve, 1000)); 
      
      await initCamera(true);
    }
    
    async function takePhoto() {
      flashEffect();
      canvasFinal.width = 1080; canvasFinal.height = 1920;
      drawVideoToCanvas(ctxFinal, 1080, 1920);
      await drawImageLayer(ctxFinal, currentMolduraUrl, 1080, 1920);
      
      const ctxPrev = canvasPreview.getContext('2d');
      canvasPreview.width = stage.clientWidth; canvasPreview.height = stage.clientHeight;
      ctxPrev.drawImage(canvasFinal, 0, 0, canvasPreview.width, canvasPreview.height);

      // Converte para Blob para obter os dados para download
      canvasFinal.toBlob(blob => {
          showResult('image', blob);
      }, 'image/png');
    }

    function startRecording() {
        isRecording = true;
        captureBtn.classList.add('recording');
        recordingTimer.style.display = 'block';
        recordingStartTime = Date.now();
        recordedChunks = [];
        finalMimeType = null;
        finalFileExtension = null;
        
        canvasFinal.width = 720; canvasFinal.height = 1280;

        const loop = () => {
            if (!isRecording) return;
            drawVideoToCanvas(ctxFinal, 720, 1280); 
            
            const img = new Image(); img.src = currentMolduraUrl;
            if(img.complete) ctxFinal.drawImage(img, 0, 0, 720, 1280);
            
            updateTimer();
            animationFrameId = requestAnimationFrame(loop);
        };
        loop();

        const canvasStream = canvasFinal.captureStream(30);
        
        if (stream && stream.getAudioTracks().length > 0) {
            canvasStream.addTrack(stream.getAudioTracks()[0]);
        }

        const preferredMimeTypes = [
            'video/mp4;codecs=avc1.42001E', 
            'video/mp4',                   
            'video/webm;codecs=vp9',       
            'video/webm;codecs=vp8',       
            'video/webm'                   
        ];
        
        let options = {};
        let selectedMimeType = null;

        for (const mimeType of preferredMimeTypes) {
            if (MediaRecorder.isTypeSupported(mimeType)) {
                selectedMimeType = mimeType;
                options = { mimeType: mimeType };
                break;
            }
        }

        if (!selectedMimeType) {
            alert("ERRO DE V√çDEO: O dispositivo n√£o suporta nenhum formato de grava√ß√£o de v√≠deo conhecido.");
            isRecording = false;
            captureBtn.classList.remove('recording');
            recordingTimer.style.display = 'none';
            return; 
        }
        
        finalMimeType = selectedMimeType;
        finalFileExtension = selectedMimeType.includes('mp4') ? 'mp4' : 'webm';


        try {
            mediaRecorder = new MediaRecorder(canvasStream, options);
        } catch(e) {
            alert("ERRO CR√çTICO NA GRAVA√á√ÉO: N√£o foi poss√≠vel iniciar o MediaRecorder. Motivo: " + e.message);
            isRecording = false;
            captureBtn.classList.remove('recording');
            recordingTimer.style.display = 'none';
            return;
        }

        mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = finishVideo;
        mediaRecorder.start();
    }

    function stopRecording() {
      isRecording = false;
      captureBtn.classList.remove('recording');
      cancelAnimationFrame(animationFrameId);
      if(mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      recordingTimer.style.display = 'none';
      recordingTimer.innerText = "00:00";
    }

    function finishVideo() {
      const simpleMimeType = finalMimeType ? finalMimeType.split(';')[0] : 'video/webm';
      const blob = new Blob(recordedChunks, { type: simpleMimeType }); 
      
      const videoURL = URL.createObjectURL(blob);
      videoPreview.src = videoURL;
      showResult('video', blob);
    }

    // --- Helpers ---

    function showResult(type, blob = null) {
      video.style.display = 'none'; molduraPreview.style.display = 'none'; cameraUI.style.display = 'none';
      resultUI.style.display = 'flex'; document.getElementById('postCaptureActions').style.display = 'flex';
      
      const timestamp = Date.now(); 

      // Limpeza de URLs e Dados antigos
      if (currentBlobUrl && currentBlobUrl.startsWith('blob:')) {
          URL.revokeObjectURL(currentBlobUrl); 
      }
      currentBlobUrl = null;
      currentDownloadData = { blob: null, filename: null }; 

      if (type === 'image') {
          canvasPreview.style.display = 'block'; videoPreview.style.display = 'none';
          
          const url = URL.createObjectURL(blob); // URL apenas para Preview/VideoPlayer
          currentBlobUrl = url; 
          
          currentDownloadData = { blob, filename: `foto_${timestamp}.png` };
      } else {
          canvasPreview.style.display = 'none'; videoPreview.style.display = 'block';
          
          const ext = finalFileExtension || 'webm'; 
          
          // O videoPreview.src j√° foi definido em finishVideo() usando a URL
          
          currentDownloadData = { blob, filename: `video_${timestamp}.${ext}` };
      }
    }

    function resetCamera() {
      // REVOGA A URL DO OBJETO QUANDO VOLTA PARA A C√ÇMERA
      if (currentBlobUrl && currentBlobUrl.startsWith('blob:')) {
          URL.revokeObjectURL(currentBlobUrl);
      }
      currentBlobUrl = null;
      currentDownloadData = { blob: null, filename: null };

      canvasPreview.style.display = 'none'; videoPreview.style.display = 'none'; videoPreview.pause();
      video.style.display = 'block'; molduraPreview.style.display = 'block';
      resultUI.style.display = 'none'; cameraUI.style.display = 'flex';
      errorMsg.innerText = "";
    }
    
    // --- Fun√ß√µes de Grava√ß√£o e Desenho (Mantidas) ---

    function updateTimer() {
        const diff = Math.floor((Date.now() - recordingStartTime) / 1000);
        const m = Math.floor(diff / 60).toString().padStart(2,'0');
        const s = (diff % 60).toString().padStart(2,'0');
        recordingTimer.innerText = `${m}:${s}`;
    }

    function drawVideoToCanvas(ctx, w, h) {
      const vw = video.videoWidth; const vh = video.videoHeight;
      if(!vw || !vh) return;
      const vidRatio = vw / vh; const canvasRatio = w / h;
      let dw, dh, dx, dy;
      if (vidRatio > canvasRatio) { dh = h; dw = h * vidRatio; dx = (w - dw) / 2; dy = 0; } 
      else { dw = w; dh = w / vidRatio; dx = 0; dy = (h - dh) / 2; }
      
      if (usingFrontCamera) {
        ctx.save();
        ctx.scale(-1, 1);
        ctx.drawImage(video, -dx - dw, dy, dw, dh);
        ctx.restore();
      } else {
        ctx.drawImage(video, dx, dy, dw, dh);
      }
    }

    function drawImageLayer(ctx, url, w, h) {
      return new Promise(r => {
        const img = new Image(); img.crossOrigin = "anonymous";
        img.onload = () => { ctx.drawImage(img, 0, 0, w, h); r(); };
        img.onerror = r; img.src = url;
      });
    }

    function flashEffect() {
        const f = document.getElementById('flash');
        f.style.opacity = '1'; setTimeout(() => f.style.opacity = '0', 150);
    }
  </script>
</body>
</html>
