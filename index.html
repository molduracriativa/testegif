<!DOCTYPE html>
<html lang="pt-BR">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
Â  <title>Crispoparte V8 - GravaÃ§Ã£o com GIF</title>
Â  <style>
Â  Â  :root {
Â  Â  Â  --accent: #25D366;
Â  Â  Â  --primary: #FF5722;
Â  Â  Â  --record: #ff0000;
Â  Â  Â  --bg-overlay: rgba(0, 0, 0, 0.65);
Â  Â  }
Â  Â Â 
Â  Â  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

Â  Â  body {Â 
Â  Â  Â  margin: 0; background: #000; color: #fff; overflow: hidden;Â 
Â  Â  Â  width: 100vw; height: 100dvh;Â 
Â  Â  Â  font-family: sans-serif;
Â  Â  }

Â  Â  .frame { position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #000; }
Â  Â  .stage { position: relative; width: 100%; height: 100%; overflow: hidden; background: #111; }

Â  Â  video, #molduraPreview, #canvasPreview, #videoPreview {Â 
Â  Â  Â  position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;Â 
Â  Â  }

Â  Â  video { transform: scaleX(1); transition: transform 0.3s; }
Â  Â  video.mirrored { transform: scaleX(-1); }

Â  Â  #canvasPreview { display: none; z-index: 6; background: #000; } 
Â  Â  #molduraPreview { pointer-events: none; z-index: 5; } 
Â  Â  #videoPreview { display: none; z-index: 6; background: #000; }

Â  Â  /* UI Layers */
Â  Â  .ui-layer {
Â  Â  Â  position: absolute; inset: 0; pointer-events: none; z-index: 20;
Â  Â  Â  display: flex; flex-direction: column; justify-content: space-between; padding: 20px;
Â  Â  }

Â  Â  .top-bar { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: auto; }

Â  Â  .timer-badge {
Â  Â  Â  Â  background: red; color: white; padding: 5px 12px; border-radius: 12px;
Â  Â  Â  Â  font-weight: bold; font-size: 16px; display: none; animation: pulse 1s infinite;
Â  Â  }
Â  Â  @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

Â  Â  .controls-bottom {
Â  Â  Â  display: flex; flex-direction: column; align-items: center; gap: 15px; pointer-events: auto; padding-bottom: 20px;
Â  Â  }

Â  Â  .mode-switch {
Â  Â  Â  Â  display: flex; background: rgba(0,0,0,0.5); border-radius: 20px; padding: 4px; backdrop-filter: blur(4px);
Â  Â  }
Â  Â  .mode-btn {
Â  Â  Â  Â  padding: 8px 20px; border-radius: 16px; border: none; background: transparent; color: #ccc; font-weight: 600; cursor: pointer;
Â  Â  }
Â  Â  .mode-btn.active { background: #fff; color: #000; }

Â  Â  .btn {Â 
Â  Â  Â  padding: 10px 16px; font-size: 14px; font-weight: 600;
Â  Â  Â  border: 2px solid rgba(255,255,255,0.3); border-radius: 20px;Â 
Â  Â  Â  background: var(--bg-overlay); color: #fff; cursor: pointer; backdrop-filter: blur(4px);
Â  Â  }
Â  Â  .btn.active { border-color: var(--accent); background: rgba(37, 211, 102, 0.2); color: var(--accent); }
Â  Â  .frame-selector { display: flex; gap: 10px; }

Â  Â  /* BotÃ£o de Captura */
Â  Â  #captureBtn {Â 
Â  Â  Â  width: 80px; height: 80px; border-radius: 50%; border: 4px solid #fff;Â 
Â  Â  Â  background: rgba(255,255,255,0.2); cursor: pointer; display: flex;Â 
Â  Â  Â  align-items: center; justify-content: center; transition: all 0.2s;
Â  Â  }
Â  Â  #captureBtn:active { transform: scale(0.95); }
Â  Â  #captureBtn svg { width: 36px; height: 36px; fill: #fff; }

Â  Â  /* Estado Gravando */
Â  Â  #captureBtn.recording { border-color: var(--record); background: rgba(255, 0, 0, 0.5); }
Â  Â  #captureBtn.recording svg { fill: var(--record); }
Â  Â  #captureBtn .stop-icon { display: none; width: 30px; height: 30px; background: var(--record); border-radius: 4px; }
Â  Â  #captureBtn.recording .stop-icon { display: block; }
Â  Â  #captureBtn.recording .cam-icon { display: none; }

Â  Â  #startScreen {Â 
Â  Â  Â  position: absolute; inset: 0; background: #000; z-index: 50;Â 
Â  Â  Â  display: flex; flex-direction: column; align-items: center; justify-content: center;Â 
Â  Â  Â  gap: 20px; text-align: center;
Â  Â  }
Â  Â  #startBtn { padding: 18px 32px; font-size: 20px; background: var(--primary); color: white; border: none; border-radius: 50px; cursor: pointer; }

Â  Â  #postCaptureActions { display: none; flex-direction: column; gap: 12px; width: 100%; max-width: 300px; pointer-events: auto; }
Â  Â Â 
Â  Â  .action-btn { width: 100%; padding: 14px; border-radius: 12px; border: none; font-size: 16px; font-weight: bold; cursor: pointer; text-align: center; text-decoration: none; display: inline-block; }
Â  Â  .btn-save { background: var(--accent); color: #fff; }
Â  Â  .btn-new { background: #555; color: #fff; }
Â  Â  .flash { position: absolute; inset: 0; background: #fff; opacity: 0; pointer-events: none; z-index: 10; transition: opacity 0.1s; }
Â  </style>
</head>
<body>

Â  <div class="frame">
Â  Â  <div class="stage" id="stage">
Â  Â  Â  <video id="camera" autoplay playsinline muted></video>
Â  Â  Â  <canvas id="canvasPreview"></canvas>Â 
Â  Â  Â  <video id="videoPreview" playsinline controls></video>
Â  Â  Â  <img id="molduraPreview" alt="Moldura" src="" /> 
Â  Â  Â  <div class="flash" id="flash"></div>

Â  Â  Â  <div class="ui-layer" id="cameraUI" style="display: none;">
Â  Â  Â  Â  <div class="top-bar">
Â  Â  Â  Â  Â  <button class="btn" id="switchBtn">ğŸ”„ Trocar</button>
Â  Â  Â  Â  Â  <div id="recordingTimer" class="timer-badge">00:00</div>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="controls-bottom">
Â  Â  Â  Â  Â  <div class="mode-switch">
Â  Â  Â  Â  Â  Â  Â <button class="mode-btn active" id="modePhoto">FOTO</button>
Â  Â  Â  Â  Â  Â  Â <button class="mode-btn" id="modeVideo">VÃDEO</button>
Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  <div class="frame-selector">
Â  Â  Â  Â  Â  Â  <button class="btn active" id="m1Btn">1</button>
Â  Â  Â  Â  Â  Â  <button class="btn" id="m2Btn">2</button>
Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  <button id="captureBtn">
Â  Â  Â  Â  Â  Â  <svg class="cam-icon" viewBox="0 0 24 24"><path d="M12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/><path d="M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 14H4V7h16v12z"/></svg>
Â  Â  Â  Â  Â  Â  <div class="stop-icon"></div>
Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>

Â  Â  Â  <div class="ui-layer" id="resultUI" style="display: none; justify-content: flex-end; align-items: center;">
Â  Â  Â  Â  <div id="postCaptureActions">
Â  Â  Â  Â  Â  <a id="downloadBtn" class="action-btn btn-save">ğŸ“¥ Baixar / Salvar</a>
Â  Â  Â  Â  Â  <button id="newPhotoBtn" class="action-btn btn-new">ğŸ”„ Novo</button>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  </div>

Â  <div id="startScreen">
Â  Â  <h2 style="margin-bottom:0">CÃ¢mera Crispoparte</h2>
Â  Â  <p style="color:#aaa; margin-top:5px">Permita cÃ¢mera e microfone</p>
Â  Â  <button id="startBtn">INICIAR</button>
Â  Â  <p id="errorMsg" style="color:red; font-size:12px; margin-top: 10px;"></p>
Â  </div>

Â  <canvas id="canvasFinal" style="display: none;"></canvas>

Â  <script>
Â  Â  // --- Config ---
Â  Â  // ğŸ’¡ NOME DO ARQUIVO ATUALIZADO PARA 'molduragif.gif'
Â  Â  const MOLDURAS = { 'm1': 'molduragif.gif', 'm2': 'moldura2.png' };
Â  Â  let currentMolduraUrl = MOLDURAS['m1'];
Â  Â  let usingFrontCamera = true;
Â  Â  let stream = null;
Â  Â  let currentMode = 'photo';Â 
Â  Â  let isRecording = false;
Â  Â  let mediaRecorder = null;
Â  Â  let recordedChunks = [];
Â  Â  let recordingStartTime = 0;
Â  Â  let animationFrameId = null;
Â  Â Â 
Â  Â  let finalMimeType = null;
Â  Â  let finalFileExtension = null;
Â  Â  let currentBlobUrl = null;Â 
Â  Â Â 
Â  Â  let currentDownloadData = { blob: null, filename: null };Â 

Â  Â  // --- DOM Elements ---
Â  Â  const video = document.getElementById('camera');
Â  Â  const stage = document.getElementById('stage');
Â  Â  const canvasPreview = document.getElementById('canvasPreview');
Â  Â  const videoPreview = document.getElementById('videoPreview');
Â  Â  const molduraPreview = document.getElementById('molduraPreview');
Â  Â  const canvasFinal = document.getElementById('canvasFinal');
Â  Â  const ctxFinal = canvasFinal.getContext('2d', { alpha: false });
Â  Â Â 
Â  Â  const startScreen = document.getElementById('startScreen');
Â  Â  const cameraUI = document.getElementById('cameraUI');
Â  Â  const resultUI = document.getElementById('resultUI');
Â  Â  const captureBtn = document.getElementById('captureBtn');
Â  Â  const recordingTimer = document.getElementById('recordingTimer');
Â  Â  const errorMsg = document.getElementById('errorMsg');
Â  Â  const downloadBtn = document.getElementById('downloadBtn');

Â  Â  // --- Events ---
Â  Â  setMoldura(document.getElementById('m1Btn'), 'm1');
Â  Â  document.getElementById('startBtn').addEventListener('click', () => initCamera(true));Â 
Â  Â  document.getElementById('switchBtn').addEventListener('click', switchCamera);
Â  Â  document.getElementById('newPhotoBtn').addEventListener('click', resetCamera);
Â  Â  document.getElementById('m1Btn').addEventListener('click', (e) => setMoldura(e.target, 'm1'));
Â  Â  document.getElementById('m2Btn').addEventListener('click', (e) => setMoldura(e.target, 'm2'));
Â  Â  document.getElementById('modePhoto').addEventListener('click', () => setMode('photo'));
Â  Â  document.getElementById('modeVideo').addEventListener('click', () => setMode('video'));
Â  Â Â 
Â  Â  captureBtn.addEventListener('click', () => {
Â  Â  Â  Â  if (currentMode === 'photo') takePhoto();
Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  Â  if (!isRecording) startRecording();
Â  Â  Â  Â  Â  Â  else stopRecording();
Â  Â  Â  Â  }
Â  Â  });

Â  Â  downloadBtn.addEventListener('click', triggerDownload);
Â  Â Â 
Â  Â  // --- Download ProgramÃ¡tico Corrigido (MÃ¡xima Prioridade) ---
Â  Â  function triggerDownload() {
Â  Â  Â  Â  const { blob, filename } = currentDownloadData;
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (!blob || !filename) {
Â  Â  Â  Â  Â  Â  alert("Erro: Arquivo nÃ£o encontrado para download. Tente uma nova gravaÃ§Ã£o.");
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â Â 
Â  Â  Â  Â  const tempLink = document.createElement('a');
Â  Â  Â  Â  tempLink.style.display = 'none';
Â  Â  Â  Â Â 
Â  Â  Â  Â  tempLink.href = url;
Â  Â  Â  Â  tempLink.download = filename;
Â  Â  Â  Â Â 
Â  Â  Â  Â  document.body.appendChild(tempLink);
Â  Â  Â  Â  tempLink.click();
Â  Â  Â  Â  document.body.removeChild(tempLink);
Â  Â  Â  Â Â 
Â  Â  Â  Â  URL.revokeObjectURL(url);Â 
Â  Â  }
Â  Â Â 
Â  Â  // --- FunÃ§Ãµes Principais de CÃ¢mera e Captura ---
Â  Â Â 
Â  Â  function setMode(mode) {
Â  Â  Â  Â  currentMode = mode;
Â  Â  Â  Â  document.getElementById('modePhoto').className = mode === 'photo' ? 'mode-btn active' : 'mode-btn';
Â  Â  Â  Â  document.getElementById('modeVideo').className = mode === 'video' ? 'mode-btn active' : 'mode-btn';
Â  Â  Â  Â  captureBtn.style.borderColor = mode === 'video' ? '#ff0000' : '#fff';
Â  Â  }

Â  Â  function setMoldura(btn, key) {
Â  Â  Â  document.querySelectorAll('.frame-selector .btn').forEach(b => b.classList.remove('active'));
Â  Â  Â  if(btn) btn.classList.add('active');
Â  Â  Â  currentMolduraUrl = MOLDURAS[key];
Â  Â  Â  molduraPreview.src = currentMolduraUrl;
Â  Â  }

Â  Â  async function initCamera(tryAudio = true) {
Â  Â  Â  if (stream) {
Â  Â  Â  Â  stream.getTracks().forEach(track => track.stop());
Â  Â  Â  Â  stream = null;Â 
Â  Â  Â  }
Â  Â  Â  errorMsg.innerText = "Solicitando permissÃµes...";

Â  Â  Â  const currentFacingMode = usingFrontCamera ? 'user' : 'environment';
Â  Â  Â Â 
Â  Â  Â  const constraintsList = [
Â  Â  Â  Â  { video: { facingMode: currentFacingMode, width: { ideal: 1280 }, height: { ideal: 720 } } },
Â  Â  Â  Â  { video: { facingMode: currentFacingMode, width: { ideal: 640 }, height: { ideal: 480 } } },
Â  Â  Â  Â  { video: { facingMode: currentFacingMode } }
Â  Â  Â  ];

Â  Â  Â  for (const videoConstraints of constraintsList) {
Â  Â  Â  Â  let constraints = { ...videoConstraints };Â 
Â  Â  Â  Â  if (tryAudio) { constraints.audio = true; }

Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  stream = await navigator.mediaDevices.getUserMedia(constraints);
Â  Â  Â  Â  Â  handleStreamSuccess(stream);
Â  Â  Â  Â  Â  return;Â 
Â  Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  console.warn(`Tentativa falhou com restriÃ§Ãµes:`, constraints, `Erro: ${err.name}`);
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  if (tryAudio) {
Â  Â  Â  Â  Â  Â errorMsg.innerText = "Erro no Ã¡udio. Tentando iniciar sem microfone...";
Â  Â  Â  Â  Â  Â await initCamera(false);Â 
Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â const errMsg = `FALHA CRÃTICA! A cÃ¢mera e o Ã¡udio nÃ£o puderam ser inicializados.`;
Â  Â  Â  Â  Â  Â errorMsg.innerText = errMsg;
Â  Â  Â  Â  Â  Â alert(errMsg);Â 
Â  Â  Â  }
Â  Â  }

Â  Â  function handleStreamSuccess(newStream) {
Â  Â  Â  Â  stream = newStream;
Â  Â  Â  Â  video.srcObject = stream;
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (usingFrontCamera) video.classList.add('mirrored');
Â  Â  Â  Â  else video.classList.remove('mirrored');

Â  Â  Â  Â  video.onloadedmetadata = () => {
Â  Â  Â  Â  Â  video.play();
Â  Â  Â  Â  Â  startScreen.style.display = 'none';
Â  Â  Â  Â  Â  cameraUI.style.display = 'flex';
Â  Â  Â  Â  Â  errorMsg.innerText = "";
Â  Â  Â  Â  };
Â  Â  }

Â  Â  async function switchCamera() {
Â  Â  Â  if (isRecording) stopRecording();Â 
Â  Â  Â  usingFrontCamera = !usingFrontCamera;
Â  Â  Â Â 
Â  Â  Â  await new Promise(resolve => setTimeout(resolve, 1000));Â 
Â  Â  Â Â 
Â  Â  Â  await initCamera(true);
Â  Â  }
Â  Â Â 
Â  Â  async function takePhoto() {
Â  Â  Â  flashEffect();
Â  Â  Â  canvasFinal.width = 1080; canvasFinal.height = 1920;
Â  Â  Â  drawVideoToCanvas(ctxFinal, 1080, 1920);
Â  Â  Â  await drawImageLayer(ctxFinal, currentMolduraUrl, 1080, 1920); 
Â  Â  Â Â 
Â  Â  Â  const ctxPrev = canvasPreview.getContext('2d');
Â  Â  Â  canvasPreview.width = stage.clientWidth; canvasPreview.height = stage.clientHeight;
Â  Â  Â  ctxPrev.drawImage(canvasFinal, 0, 0, canvasPreview.width, canvasPreview.height);

Â  Â  Â  canvasFinal.toBlob(blob => {
Â  Â  Â  Â  Â  showResult('image', blob);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  function startRecording() {
Â  Â  Â  Â  isRecording = true;
Â  Â  Â  Â  captureBtn.classList.add('recording');
Â  Â  Â  Â  recordingTimer.style.display = 'block';
Â  Â  Â  Â  recordingStartTime = Date.now();
Â  Â  Â  Â  recordedChunks = [];
Â  Â  Â  Â  finalMimeType = null;
Â  Â  Â  Â  finalFileExtension = null;
Â  Â  Â  Â Â 
Â  Â  Â  Â  canvasFinal.width = 720; 
Â  Â  Â  Â  canvasFinal.height = 1280;

Â  Â  Â  Â  // --- ConfiguraÃ§Ãµes da PosiÃ§Ã£o do GIF (512x512 no canto inferior) ---
Â  Â  Â  Â  const GIF_SIZE = 512; 
Â  Â  Â  Â  const GIF_W = GIF_SIZE;
Â  Â  Â  Â  const GIF_H = GIF_SIZE;
Â  Â  Â  Â  const GIF_X = (canvasFinal.width - GIF_W) / 2;
Â  Â  Â  Â  const GIF_Y = canvasFinal.height - GIF_H - 50; 
Â  Â  Â  Â  // ------------------------------------------------------------------

Â  Â  Â  Â  const loop = () => {
Â  Â  Â  Â  Â  Â  if (!isRecording) return;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  drawVideoToCanvas(ctxFinal, canvasFinal.width, canvasFinal.height);Â 
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // ğŸ’¡ DESENHA O FRAME ATUAL DO GIF ANIMADO NO CANVAS
Â  Â  Â  Â  Â  Â  if(molduraPreview.complete) {
Â  Â  Â  Â  Â  Â  Â  Â  ctxFinal.drawImage(molduraPreview, GIF_X, GIF_Y, GIF_W, GIF_H);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  updateTimer();
Â  Â  Â  Â  Â  Â  animationFrameId = requestAnimationFrame(loop);
Â  Â  Â  Â  };
Â  Â  Â  Â  loop();

Â  Â  Â  Â  const canvasStream = canvasFinal.captureStream(30);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (stream && stream.getAudioTracks().length > 0) {
Â  Â  Â  Â  Â  Â  canvasStream.addTrack(stream.getAudioTracks()[0]);
Â  Â  Â  Â  }

Â  Â  Â  Â  const preferredMimeTypes = [
Â  Â  Â  Â  Â  Â  'video/mp4;codecs=avc1.42001E',Â 
Â  Â  Â  Â  Â  Â  'video/webm;codecs=vp9',Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  'video/webm;codecs=vp8',Â  Â  Â  Â 
Â  Â  Â  Â  ];
Â  Â  Â  Â Â 
Â  Â  Â  Â  let options = {};
Â  Â  Â  Â  let selectedMimeType = null;

Â  Â  Â  Â  for (const mimeType of preferredMimeTypes) {
Â  Â  Â  Â  Â  Â  if (MediaRecorder.isTypeSupported(mimeType)) {
Â  Â  Â  Â  Â  Â  Â  Â  selectedMimeType = mimeType;
Â  Â  Â  Â  Â  Â  Â  Â  options = { mimeType: mimeType };
Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (!selectedMimeType) {
Â  Â  Â  Â  Â  Â  alert("ERRO: O dispositivo nÃ£o suporta gravaÃ§Ã£o de vÃ­deo. Use o modo FOTO.");
Â  Â  Â  Â  Â  Â  isRecording = false;
Â  Â  Â  Â  Â  Â  captureBtn.classList.remove('recording');
Â  Â  Â  Â  Â  Â  recordingTimer.style.display = 'none';
Â  Â  Â  Â  Â  Â  return;Â 
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  finalMimeType = selectedMimeType;
Â  Â  Â  Â  finalFileExtension = selectedMimeType.includes('mp4') ? 'mp4' : 'webm';


Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  mediaRecorder = new MediaRecorder(canvasStream, options);
Â  Â  Â  Â  } catch(e) {
Â  Â  Â  Â  Â  Â  alert("ERRO CRÃTICO NA GRAVAÃ‡ÃƒO: NÃ£o foi possÃ­vel iniciar o MediaRecorder. Motivo: " + e.message);
Â  Â  Â  Â  Â  Â  isRecording = false;
Â  Â  Â  Â  Â  Â  captureBtn.classList.remove('recording');
Â  Â  Â  Â  Â  Â  recordingTimer.style.display = 'none';
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
Â  Â  Â  Â  mediaRecorder.onstop = finishVideo;
Â  Â  Â  Â  mediaRecorder.start(); 
Â  Â  }

Â  Â  function stopRecording() {
Â  Â  Â  isRecording = false;
Â  Â  Â  captureBtn.classList.remove('recording');
Â  Â  Â  cancelAnimationFrame(animationFrameId);
Â  Â  Â  if(mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
Â  Â  Â  recordingTimer.style.display = 'none';
Â  Â  Â  recordingTimer.innerText = "00:00";
Â  Â  }

Â  Â  function finishVideo() {
Â  Â  Â  const simpleMimeType = finalMimeType ? finalMimeType.split(';')[0] : 'video/webm';
Â  Â  Â  const blob = new Blob(recordedChunks, { type: simpleMimeType });Â 
Â  Â  Â Â 
Â  Â  Â  const videoURL = URL.createObjectURL(blob);
Â  Â  Â  videoPreview.src = videoURL;
Â  Â  Â  showResult('video', blob);
Â  Â  }

Â  Â  // --- Helpers ---

Â  Â  function showResult(type, blob = null) {
Â  Â  Â  video.style.display = 'none'; molduraPreview.style.display = 'none'; cameraUI.style.display = 'none';
Â  Â  Â  resultUI.style.display = 'flex'; document.getElementById('postCaptureActions').style.display = 'flex';
Â  Â  Â Â 
Â  Â  Â  const timestamp = Date.now();Â 

Â  Â  Â  if (currentBlobUrl && currentBlobUrl.startsWith('blob:')) {
Â  Â  Â  Â  Â  URL.revokeObjectURL(currentBlobUrl);Â 
Â  Â  Â  }
Â  Â  Â  currentBlobUrl = null;
Â  Â  Â  currentDownloadData = { blob: null, filename: null };Â 

Â  Â  Â  if (type === 'image') {
Â  Â  Â  Â  Â  canvasPreview.style.display = 'block'; videoPreview.style.display = 'none';
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  const url = URL.createObjectURL(blob); 
Â  Â  Â  Â  Â  currentBlobUrl = url;Â 
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  currentDownloadData = { blob, filename: `foto_${timestamp}.png` };
Â  Â  Â  } else {
Â  Â  Â  Â  Â  canvasPreview.style.display = 'none'; videoPreview.style.display = 'block';
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  const ext = finalFileExtension || 'webm';Â 
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  currentDownloadData = { blob, filename: `video_${timestamp}.${ext}` };
Â  Â  Â  }
Â  Â  }

Â  Â  function resetCamera() {
Â  Â  Â  if (currentBlobUrl && currentBlobUrl.startsWith('blob:')) {
Â  Â  Â  Â  Â  URL.revokeObjectURL(currentBlobUrl);
Â  Â  Â  }
Â  Â  Â  currentBlobUrl = null;
Â  Â  Â  currentDownloadData = { blob: null, filename: null };

Â  Â  Â  canvasPreview.style.display = 'none'; videoPreview.style.display = 'none'; videoPreview.pause();
Â  Â  Â  video.style.display = 'block'; molduraPreview.style.display = 'block'; 
Â  Â  Â  resultUI.style.display = 'none'; cameraUI.style.display = 'flex';
Â  Â  Â  errorMsg.innerText = "";
Â  Â  }
Â  Â Â 
Â  Â  // --- FunÃ§Ãµes de GravaÃ§Ã£o e Desenho (Mantidas) ---

Â  Â  function updateTimer() {
Â  Â  Â  Â  const diff = Math.floor((Date.now() - recordingStartTime) / 1000);
Â  Â  Â  Â  const m = Math.floor(diff / 60).toString().padStart(2,'0');
Â  Â  Â  Â  const s = (diff % 60).toString().padStart(2,'0');
Â  Â  Â  Â  recordingTimer.innerText = `${m}:${s}`;
Â  Â  }

Â  Â  function drawVideoToCanvas(ctx, w, h) {
Â  Â  Â  const vw = video.videoWidth; const vh = video.videoHeight;
Â  Â  Â  if(!vw || !vh) return;
Â  Â  Â  const vidRatio = vw / vh; const canvasRatio = w / h;
Â  Â  Â  let dw, dh, dx, dy;
Â  Â  Â  if (vidRatio > canvasRatio) { dh = h; dw = h * vidRatio; dx = (w - dw) / 2; dy = 0; }Â 
Â  Â  Â  else { dw = w; dh = w / vidRatio; dx = 0; dy = (h - dh) / 2; }
Â  Â  Â Â 
Â  Â  Â  if (usingFrontCamera) {
Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  ctx.scale(-1, 1);
Â  Â  Â  Â  ctx.drawImage(video, -dx - dw, dy, dw, dh);
Â  Â  Â  Â  ctx.restore();
Â  Â  Â  } else {
Â  Â  Â  Â  ctx.drawImage(video, dx, dy, dw, dh);
Â  Â  Â  }
Â  Â  }

Â  Â  function drawImageLayer(ctx, url, w, h) {
Â  Â  Â  return new Promise(r => {
Â  Â  Â  Â  const img = new Image(); img.crossOrigin = "anonymous";
Â  Â  Â  Â  img.onload = () => { ctx.drawImage(img, 0, 0, w, h); r(); };
Â  Â  Â  Â  img.onerror = r; img.src = url;
Â  Â  Â  });
Â  Â  }

Â  Â  function flashEffect() {
Â  Â  Â  Â  const f = document.getElementById('flash');
Â  Â  Â  Â  f.style.opacity = '1'; setTimeout(() => f.style.opacity = '0', 150);
Â  Â  }
Â  </script>
</body>
</html>
